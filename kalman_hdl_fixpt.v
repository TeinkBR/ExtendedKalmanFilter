// -------------------------------------------------------------
// 
// File Name: C:\Users\Office_User\Documents\MATLAB\Examples\R2023a\hdlcoder\FixedPointTypeConversionAndRefinementExample\kalmanhdl\codegen\kalman_hdl\hdlsrc\kalman_hdl_fixpt.v
// Created: 2023-07-21 15:34:22
// 
// Generated by MATLAB 9.14, MATLAB Coder 5.6 and HDL Coder 4.1
// 
// 
// 
// -- -------------------------------------------------------------
// -- Rate and Clocking Details
// -- -------------------------------------------------------------
// Design base rate: 1
// 
// 
// Clock Enable  Sample Time
// -- -------------------------------------------------------------
// ce_out        1
// -- -------------------------------------------------------------
// 
// 
// Output Signal                 Clock Enable  Sample Time
// -- -------------------------------------------------------------
// Trajectory_filtered_out_0     ce_out        1
// Trajectory_filtered_out_1     ce_out        1
// x_jj_out_0                    ce_out        1
// x_jj_out_1                    ce_out        1
// Cov_jj_out_0                  ce_out        1
// Cov_jj_out_1                  ce_out        1
// Cov_jj_out_2                  ce_out        1
// Cov_jj_out_3                  ce_out        1
// -- -------------------------------------------------------------
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: kalman_hdl_fixpt
// Source Path: kalman_hdl_fixpt
// Hierarchy Level: 0
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module kalman_hdl_fixpt
          (clk,
           reset,
           clk_enable,
           Trajectory_totalNoise_in_0,
           Trajectory_totalNoise_in_1,
           F_0,
           F_1,
           F_2,
           F_3,
           B_0,
           B_1,
           Q_0,
           Q_1,
           Q_2,
           Q_3,
           R_0,
           R_1,
           R_2,
           R_3,
           xinit_in_0,
           xinit_in_1,
           fext_t_0,
           fext_t_1,
           ce_out,
           Trajectory_filtered_out_0,
           Trajectory_filtered_out_1,
           x_jj_out_0,
           x_jj_out_1,
           Cov_jj_out_0,
           Cov_jj_out_1,
           Cov_jj_out_2,
           Cov_jj_out_3);


  input   clk;
  input   reset;
  input   clk_enable;
  input   signed [13:0] Trajectory_totalNoise_in_0;  // sfix14_En14
  input   signed [13:0] Trajectory_totalNoise_in_1;  // sfix14_En14
  input   signed [13:0] F_0;  // sfix14_En12
  input   signed [13:0] F_1;  // sfix14_En12
  input   signed [13:0] F_2;  // sfix14_En12
  input   signed [13:0] F_3;  // sfix14_En12
  input   B_0;  // ufix1
  input   B_1;  // ufix1
  input   [13:0] Q_0;  // ufix14_En67
  input   [13:0] Q_1;  // ufix14_En67
  input   [13:0] Q_2;  // ufix14_En67
  input   [13:0] Q_3;  // ufix14_En67
  input   [13:0] R_0;  // ufix14_En20
  input   [13:0] R_1;  // ufix14_En20
  input   [13:0] R_2;  // ufix14_En20
  input   [13:0] R_3;  // ufix14_En20
  input   xinit_in_0;  // ufix1
  input   xinit_in_1;  // ufix1
  input   fext_t_0;  // ufix1
  input   fext_t_1;  // ufix1
  output  ce_out;
  output  Trajectory_filtered_out_0;  // ufix1
  output  Trajectory_filtered_out_1;  // ufix1
  output  x_jj_out_0;  // ufix1
  output  x_jj_out_1;  // ufix1
  output  [13:0] Cov_jj_out_0;  // ufix14_En67
  output  [13:0] Cov_jj_out_1;  // ufix14_En67
  output  [13:0] Cov_jj_out_2;  // ufix14_En67
  output  [13:0] Cov_jj_out_3;  // ufix14_En67


  wire enb;
  wire x_jj_not_empty;
  reg  x_jj_not_empty_1;
  wire tmp;
  wire tmp_1;
  wire tmp_2;
  wire [0:1] Trajectory_filtered;  // ufix1 [2]
  wire [0:1] xinit_in;  // ufix1 [2]
  wire [0:1] Trajectory_filtered_1;  // ufix1 [2]
  wire [0:1] tmp_3;  // ufix1 [2]
  reg  [0:1] Trajectory_filtered_2;  // ufix1 [2]
  reg  [0:1] Trajectory_filtered_reg_Trajectory_filtered;  // ufix1 [2]
  reg  [0:1] Trajectory_filtered_reg_Trajectory_filtered_next;  // ufix1 [2]
  wire [0:1] tmp_4;  // ufix1 [2]
  wire [0:1] Trajectory_filtered_out;  // ufix1 [2]
  wire tmp_5;
  wire [0:1] tmp_6;  // ufix1 [2]
  wire [0:1] x_jj;  // ufix1 [2]
  wire [0:1] tmp_7;  // ufix1 [2]
  reg  [0:1] x_jj_1;  // ufix1 [2]
  reg  [0:1] x_jj_reg_x_jj;  // ufix1 [2]
  reg  [0:1] x_jj_reg_x_jj_next;  // ufix1 [2]
  wire [0:1] x_jj_out;  // ufix1 [2]
  wire tmp_8;
  wire [13:0] Q [0:1] [0:1];  // ufix14_En67 [2x2]
  reg [13:0] tmp_9 [0:1] [0:1];  // ufix14_En67 [2x2]
  reg [13:0] c45_Cov_jj [0:3];  // ufix14_En67 [4]
  reg [13:0] tmp_10 [0:1] [0:1];  // ufix14_En67 [2x2]
  reg [13:0] c44_tmp [0:3];  // ufix14_En67 [4]
  wire [13:0] c44_Cov_jj [0:3];  // ufix14_En67 [4]
  reg [13:0] Cov_jj_reg_Cov_jj [0:3];  // ufix14_En67 [4]
  wire [13:0] Cov_jj_reg_Cov_jj_next [0:3];  // ufix14_En67 [4]
  reg [13:0] Cov_jj [0:1] [0:1];  // ufix14_En67 [2x2]
  reg [13:0] c45_Cov_jj_1 [0:3];  // ufix14_En67 [4]
  wire [13:0] c45_tmp [0:3];  // ufix14_En67 [4]
  reg [13:0] Cov_jj_out [0:1] [0:1];  // ufix14_En67 [2x2]
  reg signed [31:0] p20tmp_t_0;  // int32
  reg signed [31:0] p20tmp_t_1;  // int32
  reg signed [31:0] Cov_jj_reg_t_0;  // int32
  reg signed [31:0] p28Cov_jj_out_t_0;  // int32
  reg signed [31:0] p28Cov_jj_out_t_1;  // int32


  // HDL code generation from MATLAB function: kalman_hdl_fixpt_trueregionp16
  assign x_jj_not_empty = 1'b1;



  assign enb = clk_enable;

  // Initialize state variables
  // Persistent state variables (analogous to registers in hardware)
  // Function that performs the Kalman Filtering
  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  //                                                                          %
  //          Generated by MATLAB 9.14 and Fixed-Point Designer 7.6           %
  //                                                                          %
  // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  assign tmp =  ! x_jj_not_empty_1;



  assign tmp_1 = (tmp == 1'b0 ? x_jj_not_empty_1 :
              x_jj_not_empty);



  always @(posedge clk or posedge reset)
    begin : x_jj_not_empty_reg_process
      if (reset == 1'b1) begin
        x_jj_not_empty_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          x_jj_not_empty_1 <= tmp_1;
        end
      end
    end



  assign tmp_2 =  ! x_jj_not_empty_1;



  // HDL code generation from MATLAB function: kalman_hdl_fixpt
  assign Trajectory_filtered = {2{1'b0}};



  assign xinit_in[0] = xinit_in_0;
  assign xinit_in[1] = xinit_in_1;

  // HDL code generation from MATLAB function: kalman_hdl_fixpt_trueregionp4
  assign Trajectory_filtered_1 = xinit_in;



  always @(posedge clk or posedge reset)
    begin : Trajectory_filtered_reg_process
      if (reset == 1'b1) begin
        Trajectory_filtered_reg_Trajectory_filtered <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          Trajectory_filtered_reg_Trajectory_filtered <= Trajectory_filtered_reg_Trajectory_filtered_next;
        end
      end
    end

  always @* begin
    Trajectory_filtered_2[0] = Trajectory_filtered_reg_Trajectory_filtered[0];
    Trajectory_filtered_2[1] = Trajectory_filtered_reg_Trajectory_filtered[1];
    Trajectory_filtered_reg_Trajectory_filtered_next[0] = tmp_3[0];
    Trajectory_filtered_reg_Trajectory_filtered_next[1] = tmp_3[1];
  end



  assign tmp_3[0] = (tmp_2 == 1'b0 ? Trajectory_filtered_2[0] :
              Trajectory_filtered_1[0]);
  assign tmp_3[1] = (tmp_2 == 1'b0 ? Trajectory_filtered_2[1] :
              Trajectory_filtered_1[1]);



  // Outputs are the updated state variables
  // Kalman Filtering
  // Dimension of system
  assign tmp_4[0] = tmp_3[0];
  assign tmp_4[1] = tmp_3[1];

  assign Trajectory_filtered_out = tmp_4;



  assign Trajectory_filtered_out_0 = Trajectory_filtered_out[0];

  assign Trajectory_filtered_out_1 = Trajectory_filtered_out[1];

  assign tmp_5 =  ! x_jj_not_empty_1;



  assign tmp_6 = xinit_in;



  // HDL code generation from MATLAB function: kalman_hdl_fixpt_trueregionp12
  assign x_jj[0] = tmp_6[0];
  assign x_jj[1] = tmp_6[1];

  always @(posedge clk or posedge reset)
    begin : x_jj_reg_process
      if (reset == 1'b1) begin
        x_jj_reg_x_jj <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          x_jj_reg_x_jj <= x_jj_reg_x_jj_next;
        end
      end
    end

  always @* begin
    x_jj_1[0] = x_jj_reg_x_jj[0];
    x_jj_1[1] = x_jj_reg_x_jj[1];
    x_jj_reg_x_jj_next[0] = tmp_7[0];
    x_jj_reg_x_jj_next[1] = tmp_7[1];
  end



  assign tmp_7[0] = (tmp_5 == 1'b0 ? x_jj_1[0] :
              x_jj[0]);
  assign tmp_7[1] = (tmp_5 == 1'b0 ? x_jj_1[1] :
              x_jj[1]);



  assign x_jj_out = tmp_7;



  assign x_jj_out_0 = x_jj_out[0];

  assign x_jj_out_1 = x_jj_out[1];

  assign tmp_8 =  ! x_jj_not_empty_1;



  assign Q[0][0] = Q_0;
  assign Q[1][0] = Q_1;
  assign Q[0][1] = Q_2;
  assign Q[1][1] = Q_3;

  // HDL code generation from MATLAB function: kalman_hdl_fixpt_trueregionp8
  always @* begin

    for(p20tmp_t_1 = 32'sd0; p20tmp_t_1 <= 32'sd1; p20tmp_t_1 = p20tmp_t_1 + 32'sd1) begin
      for(p20tmp_t_0 = 32'sd0; p20tmp_t_0 <= 32'sd1; p20tmp_t_0 = p20tmp_t_0 + 32'sd1) begin
        tmp_9[p20tmp_t_0][p20tmp_t_1] = Q[p20tmp_t_0][p20tmp_t_1];
      end
    end

  end



  always @* begin
    c45_Cov_jj[0] = tmp_9[0][0];
    c45_Cov_jj[1] = tmp_9[1][0];
    c45_Cov_jj[2] = tmp_9[0][1];
    c45_Cov_jj[3] = tmp_9[1][1];
  end



  always @* begin
    c44_tmp[0] = tmp_10[0][0];
    c44_tmp[1] = tmp_10[1][0];
    c44_tmp[2] = tmp_10[0][1];
    c44_tmp[3] = tmp_10[1][1];
  end



  always @(posedge clk or posedge reset)
    begin : Cov_jj_reg_process
      if (reset == 1'b1) begin
        Cov_jj_reg_Cov_jj[0] <= 14'b00000000000000;
        Cov_jj_reg_Cov_jj[1] <= 14'b00000000000000;
        Cov_jj_reg_Cov_jj[2] <= 14'b00000000000000;
        Cov_jj_reg_Cov_jj[3] <= 14'b00000000000000;
      end
      else begin
        if (enb) begin

          for(Cov_jj_reg_t_0 = 32'sd0; Cov_jj_reg_t_0 <= 32'sd3; Cov_jj_reg_t_0 = Cov_jj_reg_t_0 + 32'sd1) begin
            Cov_jj_reg_Cov_jj[Cov_jj_reg_t_0] <= Cov_jj_reg_Cov_jj_next[Cov_jj_reg_t_0];
          end

        end
      end
    end

  assign c44_Cov_jj[0] = Cov_jj_reg_Cov_jj[0];
  assign c44_Cov_jj[1] = Cov_jj_reg_Cov_jj[1];
  assign c44_Cov_jj[2] = Cov_jj_reg_Cov_jj[2];
  assign c44_Cov_jj[3] = Cov_jj_reg_Cov_jj[3];
  assign Cov_jj_reg_Cov_jj_next[0] = c44_tmp[0];
  assign Cov_jj_reg_Cov_jj_next[1] = c44_tmp[1];
  assign Cov_jj_reg_Cov_jj_next[2] = c44_tmp[2];
  assign Cov_jj_reg_Cov_jj_next[3] = c44_tmp[3];



  always @* begin
    Cov_jj[0][0] = c44_Cov_jj[0];
    Cov_jj[1][0] = c44_Cov_jj[1];
    Cov_jj[0][1] = c44_Cov_jj[2];
    Cov_jj[1][1] = c44_Cov_jj[3];
  end



  always @* begin
    c45_Cov_jj_1[0] = Cov_jj[0][0];
    c45_Cov_jj_1[1] = Cov_jj[1][0];
    c45_Cov_jj_1[2] = Cov_jj[0][1];
    c45_Cov_jj_1[3] = Cov_jj[1][1];
  end



  assign c45_tmp[0] = (tmp_8 == 1'b0 ? c45_Cov_jj_1[0] :
              c45_Cov_jj[0]);
  assign c45_tmp[1] = (tmp_8 == 1'b0 ? c45_Cov_jj_1[1] :
              c45_Cov_jj[1]);
  assign c45_tmp[2] = (tmp_8 == 1'b0 ? c45_Cov_jj_1[2] :
              c45_Cov_jj[2]);
  assign c45_tmp[3] = (tmp_8 == 1'b0 ? c45_Cov_jj_1[3] :
              c45_Cov_jj[3]);



  always @* begin
    tmp_10[0][0] = c45_tmp[0];
    tmp_10[1][0] = c45_tmp[1];
    tmp_10[0][1] = c45_tmp[2];
    tmp_10[1][1] = c45_tmp[3];
  end



  always @* begin

    for(p28Cov_jj_out_t_1 = 32'sd0; p28Cov_jj_out_t_1 <= 32'sd1; p28Cov_jj_out_t_1 = p28Cov_jj_out_t_1 + 32'sd1) begin
      for(p28Cov_jj_out_t_0 = 32'sd0; p28Cov_jj_out_t_0 <= 32'sd1; p28Cov_jj_out_t_0 = p28Cov_jj_out_t_0 + 32'sd1) begin
        Cov_jj_out[p28Cov_jj_out_t_0][p28Cov_jj_out_t_1] = tmp_10[p28Cov_jj_out_t_0][p28Cov_jj_out_t_1];
      end
    end

  end



  assign Cov_jj_out_0 = Cov_jj_out[0][0];

  assign Cov_jj_out_1 = Cov_jj_out[1][0];

  assign Cov_jj_out_2 = Cov_jj_out[0][1];

  assign Cov_jj_out_3 = Cov_jj_out[1][1];

  assign ce_out = clk_enable;

endmodule  // kalman_hdl_fixpt

